using System;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.CSharp;
using System.Linq;
using System.Collections.Immutable;
using System.Text;

namespace StructOfArrays 
{
    [Generator]
    public class StructOfArraysGenerator : IIncrementalGenerator
    {

        private const string AttrName = "StructOfArraysAttribute";
        private const string AttrNs = "StructOfArrays";

        private const string FullyQualifiedAttributeName = $"global::{AttrNs}.{AttrName}";

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var targetStructs = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: static (s, _) => {
                        return s is StructDeclarationSyntax {AttributeLists: {Count: > 0}} decl
                            && decl.Modifiers.Any(SyntaxKind.PartialKeyword);
                    },
                    transform: static (ctx, _) => {
                        var symbol = ctx.SemanticModel.GetDeclaredSymbol(ctx.Node);
                        if (symbol is not INamedTypeSymbol s) { return null; }

                        var attributeData = symbol.GetAttributes().FirstOrDefault(
                            o => Equals(
                                o.AttributeClass?.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),   
                                FullyQualifiedAttributeName
                            )
                        );

                        return attributeData is null ? null : symbol;
                    } 
                )
                .Where(static m => m is not null)
                .Collect();

            context.RegisterSourceOutput(targetStructs, Execute);
        }

        private static void Execute(SourceProductionContext context, ImmutableArray<ISymbol> symbols)
        {
            foreach (var symbol in symbols.Where(s => s as INamedTypeSymbol is not null))
            {
                var namedSymbol = symbol as INamedTypeSymbol;

                var src = GenerateSource(namedSymbol!, context);
            }
            throw new NotImplementedException();
        }

        private static string? GenerateSource(INamedTypeSymbol symbol, SourceProductionContext ctx)
        {
            var soaName = $"{symbol.Name}SOA";


            StringBuilder source = new($@"// <auto-generated/>
#pragma warning disable 1591

namespace {symbol.ContainingNamespace.ToDisplayString()}
{{
    partial struct {soaName}
    {{

    }}
}}");
            return source.ToString();
        }


        private static void CreateDiagnosticError(
            SourceProductionContext ctx, 
            DiagnosticDescriptor descriptor,
            Location? location,
            INamedTypeSymbol symbol)
        {
            ctx.ReportDiagnostic(Diagnostic.Create(
                descriptor, 
                location, 
                symbol.Name, 
                DiagnosticSeverity.Error));
        }
    }
}

